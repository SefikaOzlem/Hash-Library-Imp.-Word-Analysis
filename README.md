# Hash-Library-Imp.-Word-Analysis
An inverted index is an index data structure, which is used to map all documents with their
content. It keeps a word and all documents containing this word. There are two types of
inverted indexes:

 Record-level inverted index contains a list of references to documents for each word.

 Word-level inverted index contains the positions of each word within a document.

1. Main Functionalities
 put(Key k, Value v)
If a word (k) is already present, then add a reference of the document (v) to the index;
otherwise create a new entry. You should store the frequency of each word with the document
identifier.
 Value get(Key k)
Search the given word (k) in the hash table. If the word is available in the table, then return an
output as shown below, otherwise return a “not found” message to the user.

>Search: cat
2 documents found
3-d.txt
1-a.txt

> Search: dool
3 documents found
2-d.txt
1-b.txt
1-c.txt

> Search: ball
Not found!

 remove(Key k)
Remove the given word (k) and the associated value from the inverted index.
 resize(int capacity)
Make the hash table dynamically growable. Put method should double the current table size if
the hash table reach the maximum load factor.

2. Hash Function
To specify an index corresponding to given string key, firstly you should generate an integer
hash code by using a special function. Then, resulting hash code has to be converted to the
range 0 to N-1 using a compression function, such as modulus operator (N is the size of hash
table).
You are expected to implement two different hash functions including simple summation
function and polynomial accumulation function.

2.1. Simple Summation Function (SSF)
You can generate the hash code of a string s with length n simply by formula.

2.2. Polynomial Accumulation Function (PAF)
The hash code of a string s can also be generated by using the following polynomial:

h (s )=ch0∗zn−1+ch1∗zn−2+...+chn−2∗z1+chn−1∗z0

where ch0 is the left most character of the string, characters are represented as numbers in
1-26 (case insensitive), and n is the length of the string. The constant z is usually a prime
number (33, 37, 39, and 41 are particularly good choices for working English words). When
the z value is chosen as 33, the string "car" has the following hash value:
h (car)=3∗332+1∗33+18∗1=3318
Note: Using this calculation on the long strings will result in numbers that will cause
overflow. You should ignore overflows or use Horner's rule to perform the calculation and
apply the modulus operator after computing each expression in Horner's rule.

3. Collision Handling
3.1. Linear Probing (LP)
Linear probing handles collisions by placing the colliding item in the next (circularly)
available table cell.
3.2. Double Hashing (DH)
Double hashing uses a secondary hash function d(k) and handles collisions by placing an item
in the first available cell of the series.


